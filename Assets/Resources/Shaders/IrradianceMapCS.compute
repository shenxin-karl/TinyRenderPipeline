// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture

struct SH3 {
    float3 m[9];
};

struct ComputeIn {
    uint3 GroupID           : SV_GroupID;           // 3D index of the thread group in the dispatch.
    uint3 GroupThreadID     : SV_GroupThreadID;     // 3D index of local thread ID in a thread group.
    uint3 DispatchThreadID  : SV_DispatchThreadID;  // 3D index of global thread ID in the dispatch.
    uint  GroupIndex        : SV_GroupIndex;        // Flattened local index of the thread within a thread group.
};

samplerCUBE             gEnvMap;
RWStructuredBuffer<SH3> gOutput;
float4                  gResolution;
float                   gCubeMapIndex;
float2                  gFaceNumBlock;

#define NUM_THREAD 8
groupshared SH3 SharedSH3[NUM_THREAD][NUM_THREAD];

const static float3x3 gRotateCubeFace[6] = {
    float3x3(float3(+0, +0, +1), float3(+0, -1, +0), float3(-1, +0, +0) ),   // +X
    float3x3(float3(+0, +0, -1), float3(+0, -1, +0), float3(+1, +0, +0) ),   // -X
    float3x3(float3(+1, +0, +0), float3(+0, +0, +1), float3(+0, +1, +0) ),   // +Y
    float3x3(float3(+1, +0, +0), float3(+0, +0, -1), float3(+0, -1, +0) ),   // -Y
    float3x3(float3(+1, +0, +0), float3(+0, -1, +0), float3(+0, +0, +1) ),   // +Z
    float3x3(float3(-1, +0, +0), float3(+0, -1, +0), float3(+0, +0, -1) )    // -Z
};

float3 GetDirection(ComputeIn cin) {
    float2 dir = (cin.DispatchThreadID.xy + 0.5) * gResolution.zw;
    float3 direction = normalize(mul(gRotateCubeFace[(uint)gCubeMapIndex], float3(dir, 0.5))); 
    return direction;
}

static const float PI = 3.141592654;
float3 CalcIrradiance(float3 direction) {
    float3 N = direction;
    float3 up 		 = abs(N.y) < 1.0 ? float3(0, 1, 0) : float3(0, 0, 1);
    float3 tangent 	 = cross(up, N);
    float3 bitangent = cross(N, tangent);
    float3x3 TBN     = transpose(float3x3(tangent, bitangent, N));

    uint sampleCount = 0;
    const float delta = 0.025;
    float3 irradianceSum = 0.0;
    for(float phi = 0.0; phi < 2.0*PI; phi += delta) {
        float cosPh = cos(phi);
        float sinPh = sin(phi);
        for (float theta = 0.0; theta < 0.5*PI; theta += delta) {
            float cosTh = cos(theta);
            float sinTh = sin(theta);
            float3 v = float3(sinTh*cosPh, sinTh*sinPh, cosTh);
            float3 dir = mul(TBN, v);
            float3 irradiance = texCUBElod(gEnvMap, float4(dir, 0.0)).rgb; 
            irradianceSum += irradiance * cosTh * sinTh;
            ++sampleCount;
        }
    }
    return ((PI / sampleCount) * irradianceSum);
}

float AreaElement(float x, float y) {
    return atan2(x * y, sqrt(x*x + y*y + 1));
}

//https://www.rorydriscoll.com/2012/01/15/cubemap-texel-solid-angle/
float DifferentialSolidAngle(ComputeIn cin) {
    float2 st = ((cin.DispatchThreadID.xy + 0.5) * gResolution.zw) * 2.0 - 1.0;
    float invResolution = gResolution.z;     
    float u = st.x; float v = st.y;
    float x0 = u - invResolution;
    float y0 = v - invResolution;
    float x1 = u + invResolution;
    float y1 = v + invResolution;
    return AreaElement(x0, y0) - AreaElement(x0, y1) - AreaElement(x1, y0) + AreaElement(x1, y1);
}

SH3 CalcSH(ComputeIn cin, float3 dir, float3 irradiance) {
    SH3 sh3;
    float solidAngle = DifferentialSolidAngle(cin);         // 求出立体角大小
    float x = dir.x; float y = dir.y; float z = dir.z;
    irradiance *= solidAngle;
    sh3.m[0] = irradiance * 0.2820948;							// y0p0
    sh3.m[1] = irradiance * 0.4886025 * y;						// y1n1
    sh3.m[2] = irradiance * 0.4886025 * z;						// y1p0
    sh3.m[3] = irradiance * 0.4886025 * x;						// y1p1
    sh3.m[4] = irradiance * 1.0925480 * x * y;					// y2n2
    sh3.m[5] = irradiance * 1.0925480 * y * z;					// y2n1
    sh3.m[6] = irradiance * 0.3153916 * ((3.0 * z * z) - 1.0);	// y2p0
    sh3.m[7] = irradiance * 1.0925480 * x * z;					// y2p1
    sh3.m[8] = irradiance * 0.5462742 * (x * x - y * y);		// y2p2
    return sh3;
}

void SHAccumulate(inout SH3 lhs, in SH3 rhs) {
    [unroll] for (int i = 0; i < 9; ++i)
        lhs.m[i] += rhs.m[i];
}

void StoreSH(ComputeIn cin, SH3 sh) {
    int x = cin.GroupThreadID.x;
    int y = cin.GroupThreadID.y;
    SharedSH3[x][y] = sh;
    GroupMemoryBarrierWithGroupSync();
    if ((cin.GroupIndex & 0x9) == 0) {     // x 和 y 都是2的倍数
        SHAccumulate(sh, SharedSH3[x+1][y+0]);
        SHAccumulate(sh, SharedSH3[x+0][y+1]);
        SHAccumulate(sh, SharedSH3[x+1][y+1]);
        SharedSH3[x][y] = sh;
    }
    GroupMemoryBarrierWithGroupSync();

    if ((cin.GroupIndex & 0x1B) == 0) {     // x 和 y 都是4的倍数
        SHAccumulate(sh, SharedSH3[x+2][y+0]);
        SHAccumulate(sh, SharedSH3[x+0][y+2]);
        SHAccumulate(sh, SharedSH3[x+2][y+2]);
        SharedSH3[x][y] = sh;
    }
    GroupMemoryBarrierWithGroupSync();

    // 把整个 group 的求和
    if (cin.GroupIndex == 0) {
        SHAccumulate(sh, SharedSH3[x+4][y+0]);
        SHAccumulate(sh, SharedSH3[x+0][y+4]);
        SHAccumulate(sh, SharedSH3[x+4][y+4]);
        uint faceStart = gCubeMapIndex * (uint)gFaceNumBlock.x * (uint)gFaceNumBlock.y;
        uint index = cin.GroupID.y * (uint)gFaceNumBlock.x + cin.GroupID.x;
        gOutput[faceStart + index] = sh;
    }
}

[numthreads(NUM_THREAD, NUM_THREAD, 1)]
void CSMain (ComputeIn cin) {
    float3 direction = GetDirection(cin);
    float3 irradiance = CalcIrradiance(direction);
    SH3 sh = CalcSH(cin, direction, irradiance);
    StoreSH(cin, sh);
}